@page "/report"
@using System.IO;
@using Blazor.FileReader;
@using dsweb_electron6.Models;
@using dsmm_server.Data;
@using dsmm_server.Models;
@using System.Collections.Concurrent;
@using System.Threading;
@using DSmm.Models;
@using DSmm.Trueskill;
@using DSmm.Repositories;
@inject ScanStateChange _state
@inject ReportService _repserv
@inject StartUp _startUp
@inject IMMrepositoryNG _mm
@inject IFileReaderService fileReaderService;

<h3>Report</h3>
<style>
    .droptarget {
        display: block;
        padding: 20px;
        margin-bottom: 10px;
        border: 1px dashed black;
        border-radius: 5px;
    }

    .droptarget-drag {
        border-color: orangered;
        font-weight: bold;
    }
</style>
<input class="form-control-sm" type="number" @bind="@_mms.RepID" />
<input class="form-control-file w-50" type="file" @ref="@inputTypeFileElement" />
<br />
<!--
<div class="@DropClass"
     @ref="@dropTargetElement"
     @ondrop="@OnDrop"
     @ondragenter="@(e => this.DropClass += " droptarget-drag")"
     @ondragleave="@(e => this.DropClass = _dropClass)">
    Drop Replay here or select it.
    @foreach (var fileInfo in FileList)
    {
        <br />@fileInfo.Name
    }
</div>
-->
<button @onclick="@ReadFile" class="btn btn-primary">Upload</button>
<button @onclick="@ClearFile" class="btn btn-primary">Clear</button>
<br />
<textarea style="max-width: 100%; overflow-y:scroll; " cols="40" rows="5">@Output</textarea>
@code {
    [Parameter]
    MMserviceNG _mms { get; set; }
    [Parameter]
    MMplayerNG _pl { get; set; }

    ElementRef inputTypeFileElement;
    ElementRef dropTargetElement;
    IFileReaderRef dropReference;
    byte[] buffer;

    const string _dropClass = "droptarget";
    string DropClass { get; set; } = _dropClass;
    string Output { get; set; }
    List<IFileInfo> FileList { get; } = new List<IFileInfo>();

    protected override async Task OnAfterRenderAsync()
    {
        //dropReference = fileReaderService.CreateReference(dropTargetElement);
        //if (dropReference != null)
        //    await dropReference.RegisterDropEventsAsync();
    }

    public async Task ClearFile()
    {
        try
        {
            await dropReference.ClearValue();
            await this.RefreshFileList();
        } catch { }
    }

    public async Task OnDrop(UIDragEventArgs e)
    {
        Output += "Dropped a file.";
        this.DropClass = _dropClass;
        this.StateHasChanged();
        await this.RefreshFileList();
    }

    private async Task RefreshFileList()
    {
        this.FileList.Clear();
        foreach (var file in await dropReference.EnumerateFilesAsync())
        {
            var fileInfo = await file.ReadFileInfoAsync();
            this.FileList.Add(fileInfo);
        }
        this.StateHasChanged();
    }

    public async Task ReadFile()
    {

        if (!_repserv.CheckName(_pl.Name))
        {
            _mms.InfoBadge = "badge-danger";
            _mms.InfoBadgeMsg = "Invalid Name";
            return;
        }

        Output = string.Empty;
        this.StateHasChanged();

        _mms.InfoBadge = "badge-info";
        _mms.InfoBadgeMsg = "Reporting";

        _state.Update = !_state.Update;

        if (_startUp.replays.ContainsKey(_mms.RepID))
            if (_startUp.replays[_mms.RepID].Count() >= 6)
                return;

        string upRep = Program.replaydir + "/" + _mms.RepID + "_" + _pl.Name + ".SC2Replay";
        if (File.Exists(upRep))
        {
            Output = "File already uploaded. If you choose the wrong replay please contact the admin.";
            return;
        }

        int i = 0;
        bool valid = true;
        ConcurrentDictionary<int, byte[]> fileBytes = new ConcurrentDictionary<int, byte[]>();

        foreach (var file in await fileReaderService.CreateReference(inputTypeFileElement).EnumerateFilesAsync())
        {
            i++;
            if (i > 1)
            {
                valid = false;
                Output += "Only one file upload is allowed.";
                break;
            }
            (valid, fileBytes) = await GetFile(file);
        }
        /**
        foreach (var file in await dropReference.EnumerateFilesAsync())
        {
            i++;
            if (i > 1)
            {
                valid = false;
                Output += "Only one file upload is allowed.";
                break;
            }
            (valid, fileBytes) = await GetFile(file);
        }
        **/

        if (i == 0)
        {
            Output = "Pelase select one file.";
            return;
        }
        if (valid == true && _mm != null)
        {
            File.Create(upRep).Dispose();
            await File.WriteAllBytesAsync(upRep, Concat(fileBytes.Values.ToArray()));
            Output += "Decoding replay..." + Environment.NewLine;
            StateHasChanged();
            dsreplay replay = await _repserv.Decode(upRep, _mms.RepID);

            Output += "Reporting replay .." + Environment.NewLine;
            StateHasChanged();
            if (!_mm.Reports.ContainsKey(replay.ID))
            {
                MMgameNG report;
                MMgameNG racereport;
                (report, racereport) = await Task.Run(() => { return MMrating.RateGame(replay, _startUp, _mm.Games.Where(x => x.ID == replay.ID).FirstOrDefault().Lobby); });
                if (report != null)
                {
                    report.ID = _mms.RepID;
                    report.Valid = await _repserv.CheckValid(replay, report);
                    _mm.Reports[replay.ID] = report;
                    _mms.InfoBadge = "badge-success";
                    _mms.InfoBadgeMsg = "Reported";
                    await _repserv.Save(report);
                    if (racereport != null)
                        await _repserv.SaveRace(racereport);
                }
                else
                {
                    _mms.InfoBadge = "badge-danger";
                    _mms.InfoBadgeMsg = "Report failed";
                }
            }
            else
            {
                _mms.InfoBadge = "badge-success";
                _mms.InfoBadgeMsg = "Reported";

            }
            _mms.ReportIsClicked = false;
            _state.Update = !_state.Update;
        }
    }

    async Task<(bool, ConcurrentDictionary<int, byte[]>)> GetFile(IFileReference file)
    {
        ConcurrentDictionary<int, byte[]> fileBytes = new ConcurrentDictionary<int, byte[]>();
        bool valid = true;
        var nl = Environment.NewLine;
        var fileInfo = await file.ReadFileInfoAsync();
        Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Name)}: {fileInfo.Name}{nl}";
        Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Size)}: {fileInfo.Size}{nl}";
        Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.Type)}: {fileInfo.Type}{nl}";
        Output += $"{nameof(IFileInfo)}.{nameof(fileInfo.LastModifiedDate)}: {fileInfo.LastModifiedDate?.ToString() ?? "(N/A)"}{nl}";
        Output += $"Reading file...";
        this.StateHasChanged();

        // 10 MB
        if (fileInfo.Size > 10485760)
        {
            Output += "File size exceeds limit.";
            valid = false;
        }
        TimeSpan t = new TimeSpan();
        t = DateTime.Now - Convert.ToDateTime(fileInfo.LastModifiedDate);
        t = t.Duration();
        if (t.Days > 1)
        {
            Output += "Not a valid replay.";
            valid = false;
        }


        using (var fs = await file.OpenReadAsync())
        {
            var bufferSize = 4096;
            var buffer = new byte[bufferSize];
            int count;
            int j = 0;
            while ((count = await fs.ReadAsync(buffer, 0, buffer.Length)) != 0)
            {

                fileBytes[j] = buffer.ToArray();
                Output += $"Read {count} bytes. {fs.Position} / {fs.Length}{nl}";

                if (j == 0)
                {
                    if (buffer[0] != 77 || buffer[1] != 80 || buffer[2] != 81)
                    {
                        Output += "Not a valid replay.";
                        valid = false;
                        break;
                    }

                }
                Interlocked.Increment(ref j);
                this.StateHasChanged();
            }
            Output += $"Done reading file {fileInfo.Name}{nl}.";
        }
        this.StateHasChanged();
        return (valid, fileBytes);
    }


    public static byte[] Concat(params byte[][] arrays)
    {
        using (var mem = new MemoryStream(arrays.Sum(a => a.Length)))
        {
            foreach (var array in arrays)
            {
                mem.Write(array, 0, array.Length);
            }
            return mem.ToArray();
        }
    }
}
